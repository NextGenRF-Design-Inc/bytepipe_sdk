% This file contains code automatically generated by a machine.
% It has not been independently verified by any human.
% All code is provided as-is for example purposes only.
% The customer assumes all risks related to the use of this code.


% Transceiver Name: ADRV9002
% Silicon Revision: C0
% Evaluation Board Revision: 2B
% Tx / Rx optimal carrier frequencies: 30 MHz to 3 GHz
% External LO optimal frequencies: 60 MHz to 6 GHz
% 
% FPGA: v8.2.21
% Device Driver API: v48.49.2
% Device Driver Client: v48.49.2
% Firmware: v0.20.0.10
% Profile Generator: v0.50.5.0
% Stream Generator Assembly: v0.7.9.0
% Transceiver Evaluation Software: v0.20.0
% ADRV9001 Plugin: v0.20.0

function Adrv9001_BeginReceiving( obj ) % obj.adrv9001Device, obj.fpga9001Device)

	INSTALL_DIRECTORY = 'C:/Program Files/Analog Devices/ADRV9001 Transceiver Evaluation Software/';
	CLIENT_DIRECTORY = 'C:/Program Files/Analog Devices/ADRV9001 Transceiver Evaluation Software/';
	NET.addAssembly([INSTALL_DIRECTORY 'AnalogDevices.Peitho.dll']);
	NET.addAssembly([INSTALL_DIRECTORY 'AnalogDevices.EvalClient.dll']);
	NET.addAssembly([INSTALL_DIRECTORY 'AnalogDevices.EvalClient.Installers.dll']);
	NET.addAssembly([CLIENT_DIRECTORY 'AnalogDevices.EvalClient.Adrv9001.Device.dll']);
	NET.addAssembly([CLIENT_DIRECTORY 'AnalogDevices.EvalClient.Fpga9001.Device.dll']);
	NET.addAssembly([CLIENT_DIRECTORY 'AnalogDevices.Peitho.dll']);
	import AnalogDevices.Peitho.*;
	import AnalogDevices.EvalClient.*;
	import AnalogDevices.EvalClient.Installers.*;
	import AnalogDevices.Peitho.*
	import AnalogDevices.EvalClient.Adrv9001.*
	import AnalogDevices.EvalClient.Adrv9001.Device.*
	import AnalogDevices.EvalClient.Fpga9001.*
	import AnalogDevices.EvalClient.Fpga9001.Device.*
	import binary_9.*
	import binary_10.*
	NET.addAssembly([CLIENT_DIRECTORY 'AnalogDevices.Adrv9001.ProfileTypes.dll']);
	import AnalogDevices.EvalClient.Adrv9001ProfileTypes.*

%	input('Ready to capture Rx data. Turn your signal source ON, then press Enter.');
	[error_code] = obj.adrv9001Device.radio.ChannelEnableMode_Set(common_Port_e.RX, common_ChannelNumber_e.CHANNEL_1, adrv9001_ChannelEnableMode_e.ADRV9001_PIN_MODE);
	[error_code] = obj.adrv9001Device.radio.ChannelEnableMode_Set(common_Port_e.RX, common_ChannelNumber_e.CHANNEL_2, adrv9001_ChannelEnableMode_e.ADRV9001_PIN_MODE);
	[error_code] = obj.adrv9001Device.rx.Gain_Set(common_ChannelNumber_e.CHANNEL_1, 247);
	[error_code] = obj.adrv9001Device.bbdc.RejectionEnable_Set(common_Port_e.RX, common_ChannelNumber_e.CHANNEL_1, adrv9001_BbdcRejectionStatus_e.ADRV9001_BBDC_REJECTION_ENABLED);
	[error_code] = obj.adrv9001Device.rx.Gain_Set(common_ChannelNumber_e.CHANNEL_2, 247);
	[error_code] = obj.adrv9001Device.bbdc.RejectionEnable_Set(common_Port_e.RX, common_ChannelNumber_e.CHANNEL_2, adrv9001_BbdcRejectionStatus_e.ADRV9001_BBDC_REJECTION_ENABLED);
	[error_code] = obj.fpga9001Device.tdd.Enable_Set(fpga9001_TddSelect_e.FPGA9001_TDDSELECT_DMA_RX1, fpga9001_TddMode_e.FPGA9001_TDD_ENABLE_HIGH);
	[error_code] = obj.fpga9001Device.tdd.Enable_Set(fpga9001_TddSelect_e.FPGA9001_TDDSELECT_RX1, fpga9001_TddMode_e.FPGA9001_TDD_ENABLE_HIGH);
	[error_code] = obj.fpga9001Device.tdd.Enable_Set(fpga9001_TddSelect_e.FPGA9001_TDDSELECT_DMA_RX2, fpga9001_TddMode_e.FPGA9001_TDD_ENABLE_HIGH);
	[error_code] = obj.fpga9001Device.tdd.Enable_Set(fpga9001_TddSelect_e.FPGA9001_TDDSELECT_RX2, fpga9001_TddMode_e.FPGA9001_TDD_ENABLE_HIGH);
	channelState_11 = adrv9001_ChannelState_e.ADRV9001_CHANNEL_STANDBY;
	[error_code, channelState_11] = obj.adrv9001Device.radio.Channel_State_Get(common_Port_e.RX, common_ChannelNumber_e.CHANNEL_1, channelState_11);
	obj.status_string = sprintf("Channel_State_Get parameter 'channelState' read back as '" + char(channelState_11) + "'\n");
	channelState_12 = adrv9001_ChannelState_e.ADRV9001_CHANNEL_STANDBY;
	[error_code, channelState_12] = obj.adrv9001Device.radio.Channel_State_Get(common_Port_e.RX, common_ChannelNumber_e.CHANNEL_2, channelState_12);
	obj.status_string = sprintf("Channel_State_Get parameter 'channelState' read back as '" + char(channelState_12) + "'\n");

end

%% Buffered String Builder
function [buff] = build_str_buff(len, s)
	buff = zeros(1, len);
	ba = uint32(s{1});
	for i = 1:length(s{1})
		buff(i) = ba(i);
	end
end
