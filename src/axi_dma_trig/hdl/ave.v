// -------------------------------------------------------------
// 
// File Name: hdl_prj\hdlsrc\dma_trig_model\ave.v
// Created: 2023-06-05 09:06:23
// 
// Generated by MATLAB 9.10 and HDL Coder 3.18
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: ave
// Source Path: dma_trig_model/dma_trig/ave
// Hierarchy Level: 1
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module ave
          (clk,
           magin,
           validin,
           magout);


  input   clk;
  input   signed [32:0] magin;  // sfix33_En30
  input   validin;
  output  [31:0] magout;  // ufix32_En30


  reg  [0:1] reduced_reg;  // ufix1 [2]
  wire [0:1] reduced_reg_next;  // ufix1 [2]
  wire validin_1;
  wire [31:0] Data_Type_Conversion_out1;  // ufix32_En30
  reg [31:0] Delay2_bypass_delay;  // ufix32
  reg [31:0] Delay2_reg;  // ufix32
  wire [31:0] Delay2_out1;  // ufix32_En30
  reg [31:0] Delay3_bypass_delay;  // ufix32
  reg [31:0] Delay3_reg;  // ufix32
  wire [31:0] Delay3_out1;  // ufix32_En30
  reg [31:0] Delay4_bypass_delay;  // ufix32
  reg [31:0] Delay4_reg;  // ufix32
  wire [31:0] Delay4_out1;  // ufix32_En30
  wire [32:0] Add_stage2_add_cast;  // ufix33_En30
  wire [32:0] Add_stage2_add_cast_1;  // ufix33_En30
  wire [32:0] Add_op_stage1;  // ufix33_En30
  wire [33:0] Add_stage3_add_cast;  // ufix34_En30
  wire [33:0] Add_stage3_add_cast_1;  // ufix34_En30
  wire [33:0] Add_op_stage2;  // ufix34_En30
  wire [33:0] Add_stage4_add_cast;  // ufix34_En30
  wire [33:0] Add_out1;  // ufix34_En30
  reg [33:0] Delay6_reg [0:3];  // ufix34 [4]
  wire [33:0] Delay6_reg_next [0:3];  // ufix34_En30 [4]
  wire [33:0] Delay6_out1;  // ufix34_En30
  wire [33:0] Bit_Shift_out1;  // ufix34_En30
  wire [31:0] Data_Type_Conversion1_out1;  // ufix32_En30
  reg [31:0] Delay1_bypass_delay;  // ufix32
  reg [31:0] Delay1_reg;  // ufix32
  wire [31:0] Delay1_out1;  // ufix32_En30

  initial begin
    reduced_reg[0] = 1'b0;
    reduced_reg[1] = 1'b0;
    Delay2_bypass_delay = 32'b00000000000000000000000000000000;
    Delay2_reg = 32'b00000000000000000000000000000000;
    Delay3_bypass_delay = 32'b00000000000000000000000000000000;
    Delay3_reg = 32'b00000000000000000000000000000000;
    Delay4_bypass_delay = 32'b00000000000000000000000000000000;
    Delay4_reg = 32'b00000000000000000000000000000000;
    Delay6_reg[0] = 34'h000000000;
    Delay6_reg[1] = 34'h000000000;
    Delay6_reg[2] = 34'h000000000;
    Delay6_reg[3] = 34'h000000000;
    Delay1_bypass_delay = 32'b00000000000000000000000000000000;
    Delay1_reg = 32'b00000000000000000000000000000000;
  end

  always @(posedge clk)
    begin : reduced_process
      reduced_reg[0] <= reduced_reg_next[0];
      reduced_reg[1] <= reduced_reg_next[1];
    end

  assign validin_1 = reduced_reg[1];
  assign reduced_reg_next[0] = validin;
  assign reduced_reg_next[1] = reduced_reg[0];



  assign Data_Type_Conversion_out1 = magin[31:0];



  always @(posedge clk)
    begin : Delay2_process
      if (validin_1) begin
        Delay2_bypass_delay <= Delay2_reg;
        Delay2_reg <= Data_Type_Conversion_out1;
      end
    end

  assign Delay2_out1 = (validin_1 == 1'b1 ? Delay2_reg :
              Delay2_bypass_delay);



  always @(posedge clk)
    begin : Delay3_process
      if (validin_1) begin
        Delay3_bypass_delay <= Delay3_reg;
        Delay3_reg <= Delay2_out1;
      end
    end

  assign Delay3_out1 = (validin_1 == 1'b1 ? Delay3_reg :
              Delay3_bypass_delay);



  always @(posedge clk)
    begin : Delay4_process
      if (validin_1) begin
        Delay4_bypass_delay <= Delay4_reg;
        Delay4_reg <= Delay3_out1;
      end
    end

  assign Delay4_out1 = (validin_1 == 1'b1 ? Delay4_reg :
              Delay4_bypass_delay);



  assign Add_stage2_add_cast = {1'b0, Delay4_out1};
  assign Add_stage2_add_cast_1 = {1'b0, Delay3_out1};
  assign Add_op_stage1 = Add_stage2_add_cast + Add_stage2_add_cast_1;



  assign Add_stage3_add_cast = {1'b0, Add_op_stage1};
  assign Add_stage3_add_cast_1 = {2'b0, Delay2_out1};
  assign Add_op_stage2 = Add_stage3_add_cast + Add_stage3_add_cast_1;



  assign Add_stage4_add_cast = {2'b0, Data_Type_Conversion_out1};
  assign Add_out1 = Add_op_stage2 + Add_stage4_add_cast;



  always @(posedge clk)
    begin : Delay6_process
      Delay6_reg[0] <= Delay6_reg_next[0];
      Delay6_reg[1] <= Delay6_reg_next[1];
      Delay6_reg[2] <= Delay6_reg_next[2];
      Delay6_reg[3] <= Delay6_reg_next[3];
    end

  assign Delay6_out1 = Delay6_reg[3];
  assign Delay6_reg_next[0] = Add_out1;
  assign Delay6_reg_next[1] = Delay6_reg[0];
  assign Delay6_reg_next[2] = Delay6_reg[1];
  assign Delay6_reg_next[3] = Delay6_reg[2];



  assign Bit_Shift_out1 = Delay6_out1 >> 8'd2;



  assign Data_Type_Conversion1_out1 = Bit_Shift_out1[31:0];



  always @(posedge clk)
    begin : Delay1_process
      if (validin_1) begin
        Delay1_bypass_delay <= Delay1_reg;
        Delay1_reg <= Data_Type_Conversion1_out1;
      end
    end

  assign Delay1_out1 = (validin_1 == 1'b1 ? Delay1_reg :
              Delay1_bypass_delay);



  assign magout = Delay1_out1;

endmodule  // ave

