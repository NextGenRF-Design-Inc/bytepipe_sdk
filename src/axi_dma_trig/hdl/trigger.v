// -------------------------------------------------------------
// 
// File Name: hdl_prj\hdlsrc\dma_trig_model\trigger.v
// Created: 2023-06-05 09:06:23
// 
// Generated by MATLAB 9.10 and HDL Coder 3.18
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: trigger
// Source Path: dma_trig_model/dma_trig/trigger
// Hierarchy Level: 1
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module trigger
          (clk,
           reset_x,
           threshold,
           magin,
           edge_rsvd,
           type_rsvd,
           ext_trig,
           enable,
           trigger_1);


  input   clk;
  input   reset_x;
  input   [31:0] threshold;  // ufix32_En30
  input   [31:0] magin;  // ufix32_En30
  input   edge_rsvd;  // ufix1
  input   [1:0] type_rsvd;  // ufix2
  input   ext_trig;
  input   enable;
  output  trigger_1;


  wire [1:0] two_out1;  // ufix2
  wire Relational_Operator2_relop1;
  reg  Delay5_out1;
  reg  [0:1] delayMatch6_reg;  // ufix1 [2]
  wire [0:1] delayMatch6_reg_next;  // ufix1 [2]
  wire Delay5_out1_1;
  reg  [0:1] delayMatch5_reg;  // ufix1 [2]
  wire [0:1] delayMatch5_reg_next;  // ufix1 [2]
  wire enable_1;
  reg  [0:1] delayMatch3_reg;  // ufix1 [2]
  wire [0:1] delayMatch3_reg_next;  // ufix1 [2]
  wire edge_rsvd_1;  // ufix1
  reg [1:0] delayMatch1_reg [0:1];  // ufix2 [2]
  wire [1:0] delayMatch1_reg_next [0:1];  // ufix2 [2]
  wire [1:0] type_rsvd_1;  // ufix2
  reg [31:0] Delay1_out1;  // ufix32_En30
  reg [31:0] delayMatch_reg [0:1];  // ufix32 [2]
  wire [31:0] delayMatch_reg_next [0:1];  // ufix32_En30 [2]
  wire [31:0] threshold_1;  // ufix32_En30
  wire Relational_Operator_relop1;
  reg  Delay2_out1;
  reg  [0:1] delayMatch2_reg;  // ufix1 [2]
  wire [0:1] delayMatch2_reg_next;  // ufix1 [2]
  wire ext_trig_1;
  wire [1:0] zero_out1;  // ufix2
  wire zero_out1_dtc;
  wire zero_out1_dtc_1;
  wire Index_Vector1_out1;
  reg  Delay10_out1;
  wire rising_out1;
  wire falling_out1;
  wire Index_Vector_out1;
  reg  Delay4_out1;
  wire valid;
  reg  [0:1] delayMatch4_reg;  // ufix1 [2]
  wire [0:1] delayMatch4_reg_next;  // ufix1 [2]
  wire valid_1;
  wire Bitwise_Operator1_out1;
  wire latch;
  wire valid_2;

  initial begin
    Delay5_out1 = 1'b0;
    delayMatch6_reg[0] = 1'b0;
    delayMatch6_reg[1] = 1'b0;
    delayMatch5_reg[0] = 1'b0;
    delayMatch5_reg[1] = 1'b0;
    delayMatch3_reg[0] = 1'b0;
    delayMatch3_reg[1] = 1'b0;
    delayMatch1_reg[0] = 2'b00;
    delayMatch1_reg[1] = 2'b00;
    Delay1_out1 = 32'b00000000000000000000000000000000;
    delayMatch_reg[0] = 32'b00000000000000000000000000000000;
    delayMatch_reg[1] = 32'b00000000000000000000000000000000;
    Delay2_out1 = 1'b0;
    delayMatch2_reg[0] = 1'b0;
    delayMatch2_reg[1] = 1'b0;
    Delay10_out1 = 1'b0;
    Delay4_out1 = 1'b0;
    delayMatch4_reg[0] = 1'b0;
    delayMatch4_reg[1] = 1'b0;
  end

  assign two_out1 = 2'b10;



  assign Relational_Operator2_relop1 = type_rsvd == two_out1;



  always @(posedge clk)
    begin : Delay5_process
      Delay5_out1 <= Relational_Operator2_relop1;
    end



  always @(posedge clk)
    begin : delayMatch6_process
      delayMatch6_reg[0] <= delayMatch6_reg_next[0];
      delayMatch6_reg[1] <= delayMatch6_reg_next[1];
    end

  assign Delay5_out1_1 = delayMatch6_reg[1];
  assign delayMatch6_reg_next[0] = Delay5_out1;
  assign delayMatch6_reg_next[1] = delayMatch6_reg[0];



  always @(posedge clk)
    begin : delayMatch5_process
      delayMatch5_reg[0] <= delayMatch5_reg_next[0];
      delayMatch5_reg[1] <= delayMatch5_reg_next[1];
    end

  assign enable_1 = delayMatch5_reg[1];
  assign delayMatch5_reg_next[0] = enable;
  assign delayMatch5_reg_next[1] = delayMatch5_reg[0];



  always @(posedge clk)
    begin : delayMatch3_process
      delayMatch3_reg[0] <= delayMatch3_reg_next[0];
      delayMatch3_reg[1] <= delayMatch3_reg_next[1];
    end

  assign edge_rsvd_1 = delayMatch3_reg[1];
  assign delayMatch3_reg_next[0] = edge_rsvd;
  assign delayMatch3_reg_next[1] = delayMatch3_reg[0];



  always @(posedge clk)
    begin : delayMatch1_process
      delayMatch1_reg[0] <= delayMatch1_reg_next[0];
      delayMatch1_reg[1] <= delayMatch1_reg_next[1];
    end

  assign type_rsvd_1 = delayMatch1_reg[1];
  assign delayMatch1_reg_next[0] = type_rsvd;
  assign delayMatch1_reg_next[1] = delayMatch1_reg[0];



  always @(posedge clk)
    begin : Delay1_process
      Delay1_out1 <= magin;
    end



  always @(posedge clk)
    begin : delayMatch_process
      delayMatch_reg[0] <= delayMatch_reg_next[0];
      delayMatch_reg[1] <= delayMatch_reg_next[1];
    end

  assign threshold_1 = delayMatch_reg[1];
  assign delayMatch_reg_next[0] = threshold;
  assign delayMatch_reg_next[1] = delayMatch_reg[0];



  assign Relational_Operator_relop1 = Delay1_out1 > threshold_1;



  always @(posedge clk)
    begin : Delay2_process
      Delay2_out1 <= Relational_Operator_relop1;
    end



  always @(posedge clk)
    begin : delayMatch2_process
      delayMatch2_reg[0] <= delayMatch2_reg_next[0];
      delayMatch2_reg[1] <= delayMatch2_reg_next[1];
    end

  assign ext_trig_1 = delayMatch2_reg[1];
  assign delayMatch2_reg_next[0] = ext_trig;
  assign delayMatch2_reg_next[1] = delayMatch2_reg[0];



  assign zero_out1 = 2'b00;



  assign zero_out1_dtc = (zero_out1 != 2'b00 ? 1'b1 :
              1'b0);



  assign zero_out1_dtc_1 = (zero_out1 != 2'b00 ? 1'b1 :
              1'b0);



  assign Index_Vector1_out1 = (type_rsvd_1 == 2'b00 ? Delay2_out1 :
              (type_rsvd_1 == 2'b01 ? ext_trig_1 :
              (type_rsvd_1 == 2'b10 ? zero_out1_dtc :
              zero_out1_dtc_1)));



  always @(posedge clk)
    begin : Delay10_process
      Delay10_out1 <= Index_Vector1_out1;
    end



  rising u_rising (.clk(clk),
                   .level(Delay10_out1),
                   .rising_1(rising_out1)
                   );

  falling u_falling (.clk(clk),
                     .level(Delay10_out1),
                     .falling_1(falling_out1)
                     );

  assign Index_Vector_out1 = (edge_rsvd_1 == 1'b0 ? rising_out1 :
              falling_out1);



  always @(posedge clk)
    begin : Delay4_process
      Delay4_out1 <= Index_Vector_out1;
    end



  assign valid =  ~ enable;



  always @(posedge clk)
    begin : delayMatch4_process
      delayMatch4_reg[0] <= delayMatch4_reg_next[0];
      delayMatch4_reg[1] <= delayMatch4_reg_next[1];
    end

  assign valid_1 = delayMatch4_reg[1];
  assign delayMatch4_reg_next[0] = valid;
  assign delayMatch4_reg_next[1] = delayMatch4_reg[0];



  assign Bitwise_Operator1_out1 = Delay4_out1 | valid_1;



  Sample_and_Hold u_Sample_and_Hold (.clk(clk),
                                     .reset_x(reset_x),
                                     .In(enable_1),
                                     .Trigger(Bitwise_Operator1_out1),
                                     .alpha(latch)
                                     );

  assign valid_2 = Delay5_out1_1 | latch;



  assign trigger_1 = valid_2;

endmodule  // trigger

